# AuditIntake API Platform Integration Guide

## Overview

The `AuditIntake` entity is fully integrated with Symfony API Platform, providing automatic REST API endpoints for creating, reading, updating, and deleting audit intake records. This integration allows the frontend `AuditWizard.tsx` component to seamlessly save audit data to the database.

## API Endpoints

The following endpoints are automatically generated by API Platform:

- `GET /api/v1/audits/intakes` - List all audit intakes
- `POST /api/v1/audits/intakes` - Create a new audit intake
- `GET /api/v1/audits/intakes/{id}` - Get a specific audit intake
- `PATCH /api/v1/audits/intakes/{id}` - Update an audit intake

## Data Structure

### Frontend to Backend Mapping

The frontend `AuditWizard.tsx` sends data in this format:

```typescript
{
  websiteUrl: string,
  contactName: string,
  contactEmail: string,
  cms: string,
  techStack: {
    industry: string,
    goals: string[],
    competitors: string,
    budget: string,
    tier: string,
    notes: string
  },
  notes: string,
  status: string
}
```

This maps to the `AuditIntake` entity structure:

```php
class AuditIntake
{
    private string $websiteUrl;
    private ?string $contactName;
    private ?string $contactEmail;
    private string $cms;
    private ?array $techStack;
    private ?string $notes;
    private string $status;
    // ... other fields
}
```

## Authentication & Authorization

### Current Setup
- All endpoints require authentication via JWT token
- The `AuditIntake` entity requires a `Client` association
- Users must have appropriate roles to access the endpoints

### Required Flow
1. **User Registration/Login**: Use existing `/api/v1/auth/register` or `/api/v1/auth/login` endpoints
2. **Client Creation**: Either through registration or existing client association
3. **Audit Intake Creation**: Create audit intake associated with the client

## Integration Steps

### 1. Frontend Authentication
The frontend already handles authentication through the existing auth system:

```typescript
// Login
const authResult = await loginUser(email, password);

// Register (if new user)
const authResult = await registerUser(account);
```

### 2. Client Association
The `AuditIntake` entity requires a `Client` entity. This can be handled in several ways:

#### Option A: Use Existing Client
If the user is already associated with a client, use that client ID.

#### Option B: Create New Client
Use the existing client creation endpoints:

```typescript
// Create client first
const clientResponse = await fetch('/api/v1/clients', {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${token}` },
  body: JSON.stringify({
    name: form.companyName,
    website: form.website,
    // ... other client data
  })
});
```

### 3. Audit Intake Creation
Once authenticated and with a client, create the audit intake:

```typescript
const auditIntakeData = {
  websiteUrl: form.website,
  contactName: `${account.firstName} ${account.lastName}`,
  contactEmail: account.email,
  cms: 'custom',
  techStack: {
    industry: form.industry,
    goals: form.goals,
    competitors: form.competitors,
    budget: form.monthlyBudget,
    tier: form.tier,
    notes: form.notes,
  },
  notes: form.notes,
  status: 'draft'
};

const response = await fetch('/api/v1/audits/intakes', {
  method: 'POST',
  headers: { 
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(auditIntakeData)
});
```

## Testing

### Running Tests
```bash
cd backend
php bin/phpunit tests/Controller/Api/V1/AuditIntakeApiTest.php
```

### Test Coverage
The test suite verifies:
- API endpoints are accessible
- Entity structure is correct
- Data mapping works properly
- Authentication requirements are enforced

## Error Handling

### Common Issues

1. **401 Unauthorized**: User not authenticated or token expired
2. **400 Bad Request**: Invalid data format or missing required fields
3. **404 Not Found**: Client not found or audit intake doesn't exist
4. **422 Validation Error**: Data validation failed

### Frontend Error Handling
The frontend already includes error handling:

```typescript
if (!response.ok) {
  const error = await response.json();
  throw new Error(error.error || 'Failed to create audit');
}
```

## Security Considerations

1. **Authentication**: All endpoints require valid JWT tokens
2. **Authorization**: Users can only access audit intakes associated with their clients
3. **Data Validation**: Input is validated both on frontend and backend
4. **SQL Injection**: Protected by Doctrine ORM parameter binding
5. **Domain Validation**: Custom `DomainOrUrl` constraint accepts both domain names (e.g., `smcnary.github.io`) and full URLs (e.g., `https://smcnary.github.io`)

## Future Enhancements

1. **Bulk Operations**: Add support for bulk audit intake creation
2. **Advanced Filtering**: Add filtering and sorting capabilities
3. **File Uploads**: Support for document attachments
4. **Webhooks**: Notify external systems when audit intakes are created/updated
5. **Audit Trail**: Track changes to audit intake records

## Troubleshooting

### API Platform Not Working
1. Check that API Platform is properly configured in `config/packages/api_platform.yaml`
2. Verify entity annotations are correct
3. Clear cache: `php bin/console cache:clear`

### Database Issues
1. Run migrations: `php bin/console doctrine:migrations:migrate`
2. Validate schema: `php bin/console doctrine:schema:validate`
3. Check entity relationships are properly configured

### Authentication Issues
1. Verify JWT configuration in `config/packages/lexik_jwt_authentication.yaml`
2. Check user roles and permissions
3. Ensure client association is properly set up

## Conclusion

The `AuditIntake` entity is fully integrated with API Platform and ready for production use. The frontend `AuditWizard.tsx` component can now seamlessly save audit data to the database through the REST API endpoints.

The integration provides:
- ✅ Automatic REST API endpoints
- ✅ Proper authentication and authorization
- ✅ Data validation and error handling
- ✅ Test coverage
- ✅ Scalable architecture

No additional controller code is needed - API Platform handles all the CRUD operations automatically based on the entity configuration.
